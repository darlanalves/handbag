{"version":3,"file":"handbag.min.js","sources":["../src/index.js"],"sourcesContent":["const toString = Object.prototype.toString;\nconst INSTANTIATING = {};\nconst INJECTOR_FROZEN_ERROR = 'This injector is frozen and cannot be modified';\n\nconst is = {\n    array: (value) => {\n        return '[object Array]' === toString.call(value);\n    },\n\n    function: (value) => {\n        return typeof value === 'function';\n    },\n\n    object: (value) => {\n        return value !== null && typeof value === 'object';\n    }\n};\n\nconst FN_ARGS = /^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m;\n\n/**\n * Dependency Injection container\n */\nclass Injector {\n    constructor() {\n        this._reset();\n    }\n\n    /**\n     * @param {string} name\n     * @param {Object} [locals]     Map of injectables to override\n     */\n    get(name, locals) {\n        if (is.array(name)) {\n            return name.map(function(item) {\n                return this.get(item, locals);\n            }, this);\n        }\n\n        if (name === 'handbag') {\n            return this;\n        }\n\n        if (locals && locals.hasOwnProperty(name)) {\n            return locals[name];\n        }\n\n        const cache = this.$cache;\n\n        if (cache.hasOwnProperty(name) && cache[name] !== INSTANTIATING) {\n            return cache[name];\n        }\n\n        const resource = this._getOrCreate(name, locals);\n\n        if (true === this.$privates[name]) {\n            delete cache[name];\n        }\n\n        // stack.pop();\n        return resource;\n    }\n\n    /**\n     * @private\n     */\n    _getOrCreate(name, locals) {\n        const cache = this.$cache;\n        const stack = this.$stack;\n        const providers = this.$providers;\n\n        let error;\n\n        stack.push(name);\n\n        try {\n            if (!providers.hasOwnProperty(name)) {\n                throw new Error('Dependency not found: ' + stack.join(' <- '));\n            }\n\n            if (cache[name] === INSTANTIATING) {\n                throw new Error('Circular dependency found: ' + stack.join(' <- '));\n            }\n\n            cache[name] = INSTANTIATING;\n            cache[name] = this.instantiate(providers[name], locals);\n        } catch (e) {\n            if (cache[name] === INSTANTIATING) {\n                delete cache[name];\n            }\n\n            error = e;\n        } finally {\n            stack.pop();\n        }\n\n        if (error) {\n            throw error;\n        }\n\n        return cache[name];\n    }\n\n    /**\n     * @param {string} name\n     * @return {boolean}\n     */\n    has(name) {\n        return this.$cache.hasOwnProperty(name) || this.$providers.hasOwnProperty(name);\n    }\n\n    /**\n     * Register a provider for a value meant to be a singleton instance\n     * @param {string} name\n     * @param {Function|Class} value\n     */\n    provideShared(name, value) {\n        return this.provide(name, value, true);\n    }\n\n    /**\n     * Register a provider for a value meant to be recreated everytime it is required\n     * @param {string} name\n     * @param {Function|Class} value\n     */\n    provideNotShared(name, value) {\n        return this.provide(name, value, false);\n    }\n\n    /**\n     * Register a provider for a value\n     * @param {string} name\n     * @param {Function|Class} value\n     * @param {boolean} isShared\n     */\n    provide(name, value, isShared = true) {\n        if (this.$frozen) {\n            throw new Error(INJECTOR_FROZEN_ERROR);\n        }\n\n        if (is.array(value)) {\n            let provider = value[value.length - 1];\n\n            if (!is.function(provider)) {\n                throw new Error('Invalid provider for ' + name);\n            }\n\n            this._register(name, value, isShared);\n\n            return this;\n        }\n\n        if (is.function(value)) {\n            let provider = this._parseDependencies(value);\n            provider.push(value);\n            this._register(name, provider, isShared);\n\n            return this;\n        }\n\n        this.constant(name, value);\n        return this;\n    }\n\n    /**\n     * Provider to any value that won't change during the injector lifecycle\n     * @param {string} name\n     * @param {*} value\n     */\n    constant(name, value) {\n        if (this.$frozen) {\n            throw new Error(INJECTOR_FROZEN_ERROR);\n        }\n\n        this.$cache[name] = value;\n        return this;\n    }\n\n    /**\n     * @param {Function} Type\n     * @param {Object} [locals]\n     */\n    instantiate(Type, locals) {\n        var Constructor = function() {},\n            instance, returnedValue;\n\n        Constructor.prototype = (is.array(Type) ? Type[Type.length - 1] : Type).prototype;\n\n        instance = new Constructor();\n        returnedValue = this.invoke(Type, instance, locals);\n        instance = (is.object(returnedValue) || is.function(returnedValue)) ? returnedValue : instance;\n\n        return instance;\n    }\n\n    /**\n     * @param {Function|Array} invokable    Either a function or an array with dependencies and a function\n     * @param {Object} context\n     * @param {Object} [locals]\n     *\n     * @example\n     *\n     * function fn(foo) {}\n     * const context = {};\n     *\n     * handbag.invoke(fn, context, { foo: 1 });\n     * handbag.invoke(['foo', fn], context, { foo: 1 });\n     */\n    invoke(invokable, context, locals) {\n        let _invokable;\n\n        if (is.array(invokable)) {\n            _invokable = this._getInvokableFromArray(invokable);\n        } else if (is.function(invokable)) {\n            _invokable = this._getInvokableFromFunction(invokable);\n        }\n\n        if (!(_invokable && _invokable.method)) {\n            throw new Error('Invalid invokable value');\n        }\n\n        let { dependencies } = _invokable;\n\n        if (dependencies.length) {\n            dependencies = this.get(dependencies, locals);\n        }\n\n        return _invokable.method.apply(context || null, dependencies);\n    }\n\n    _getInvokableFromArray(array) {\n        let dependencies = array.slice(0);\n        let method = dependencies.pop();\n\n        if (!is.function(method)) {\n            method = null;\n        }\n\n        return { dependencies, method };\n    }\n\n    _getInvokableFromFunction(fn) {\n        let dependencies = fn.$inject || this._parseDependencies(fn);\n\n        return { dependencies, method: fn };\n    }\n\n    _annotateConstructor() {\n        var args = Array.from(arguments),\n            Constructor = args.pop();\n\n        Constructor.$inject = args;\n\n        return Constructor;\n    }\n\n    _parseDependencies(fn) {\n        var match = fn.toString().match(FN_ARGS),\n            fnArgs = match && match[1];\n\n        return fnArgs && fnArgs.split(',').map(function(arg) {\n            return arg.trim();\n        }) || [];\n    }\n\n    _register(name, provider, isShared) {\n        if (this.$providers.hasOwnProperty(name)) {\n            throw new Error('Cannot register a dependency that already exists: ' + name);\n        }\n\n        this.$providers[name] = this._annotateConstructor.apply(null, provider);\n\n        if (!isShared) {\n            this.$privates[name] = true;\n        }\n    }\n\n    /**\n     * Lock this injector to prevent any further registration of values\n     */\n    freeze() {\n        this.$frozen = true;\n    }\n\n    /**\n     * Reset all the values declared in this injector\n     * @private\n     */\n    _reset() {\n        this.$cache = {};\n        this.$providers = {};\n        this.$privates = {};\n        this.$stack = [];\n    }\n\n    /**\n     * @return {Injector}\n     */\n    static create() {\n        return new Injector();\n    }\n}\n\nexport default Injector;\n"],"names":["toString","Object","prototype","INSTANTIATING","INJECTOR_FROZEN_ERROR","is","value","call","FN_ARGS","Injector","_reset","name","locals","array","map","item","this","get","hasOwnProperty","cache","$cache","resource","_getOrCreate","$privates","stack","$stack","providers","$providers","error","push","Error","join","instantiate","e","pop","provide","isShared","$frozen","provider","length","_register","_provider","_parseDependencies","constant","Type","instance","returnedValue","Constructor","invoke","object","invokable","context","_invokable","_getInvokableFromArray","_getInvokableFromFunction","method","dependencies","apply","slice","fn","$inject","args","Array","from","arguments","match","fnArgs","split","arg","trim","_annotateConstructor"],"mappings":"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"}