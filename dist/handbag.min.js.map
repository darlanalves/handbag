{"version":3,"file":"handbag.min.js","sources":["../src/index.js"],"sourcesContent":["const toString = Object.prototype.toString;\nconst INSTANTIATING = {};\nconst INJECTOR_FROZEN_ERROR = 'This injector is frozen and cannot be modified';\n\nconst is = {\n    array: (value) => {\n        return '[object Array]' === toString.call(value);\n    },\n\n    function: (value) => {\n        return typeof value === 'function';\n    },\n\n    object: (value) => {\n        return value !== null && typeof value === 'object';\n    }\n};\n\nconst FN_ARGS = /^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m;\nlet UID = 1;\n/**\n * Dependency Injection container\n */\nclass Injector {\n    constructor() {\n        this._reset();\n        this.id = UID++;\n    }\n\n    /**\n     * @param {string|Symbol} name\n     * @param {Object} [locals={}]     Map of injectables to override\n     */\n    get(name, locals = {}) {\n        if (!name) {\n            throw new Error('Dependency name is required');\n        }\n\n        if (is.array(name)) {\n            return name.map(function(item) {\n                return this.get(item, locals);\n            }, this);\n        }\n\n        if (name === 'handbag') {\n            return this;\n        }\n\n        let isInLocals = locals.hasOwnProperty(name);\n        if (!isInLocals && typeof locals.getOwnPropertySymbols === 'function') {\n            isInLocals = locals.getOwnPropertySymbols().indexOf(name) !== -1;\n        }\n\n        if (isInLocals) {\n            return locals[name];\n        }\n\n        const stack = this.$stack;\n\n        if (!this.has(name)) {\n            let error = 'Dependency not found: ' + name +\n                (stack.length ? ' (' + stack.join(' <- ') + ')' : '');\n\n            throw new Error(error);\n        }\n\n        return this.getResource(name, locals);\n    }\n\n    /**\n     * @param {string|Symbol} name\n     * @param {Object} [locals]     Map of injectables to override\n     */\n    getResource(name, locals) {\n        if (this.hasLocalProvider(name)) {\n            return this.getLocalResource(name, locals);\n        }\n\n        const injector = this.$children.find(i => i.has(name));\n        return injector.getResource(name, locals);\n    }\n\n    /**\n     * Get a value from cache or instantiate a value from registered provider\n     * @param {string|Symbol} name\n     * @param {Object} [locals]     Map of injectables to override\n     * @private\n     */\n    getLocalResource(name, locals) {\n        const cache = this.$cache;\n        const stack = this.$stack;\n\n        if (cache.has(name) && !this._isInstantiating(name)) {\n            return cache.get(name);\n        }\n\n        let error, value;\n        stack.push(name);\n\n        try {\n            if (this._isInstantiating(name)) {\n                throw new Error('Circular dependency found: ' + stack.join(' <- '));\n            }\n\n            cache.set(name, INSTANTIATING);\n            value = this.instantiate(name, locals);\n\n            if (value === undefined) {\n                throw new Error('Invalid value returned on constructor of ' + name);\n            }\n\n            cache.set(name, value);\n        } catch (e) {\n            if (this._isInstantiating(name)) {\n                cache.delete(name);\n            }\n\n            error = e;\n        } finally {\n            stack.pop();\n        }\n\n        if (error) {\n            throw error;\n        }\n\n        if (true === this.$privates[name]) {\n            cache.delete(name);\n        }\n\n        return value;\n    }\n\n    _isInstantiating(name) {\n        return this.$cache.get(name) === INSTANTIATING;\n    }\n\n    /**\n     * Check for a provider in this injector and all children\n     * @param {string|Symbol} name\n     * @return {boolean}\n     */\n    has(name) {\n        return this.hasLocalProvider(name) || this.hasChildProvider(name);\n    }\n\n    /**\n     * Check for a provider only in this instance (not checking on children)\n     * @param {string|Symbol} name\n     * @return {boolean}\n     */\n    hasLocalProvider(name) {\n        return this.$cache.has(name) || this.$providers.has(name);\n    }\n\n    /**\n     * Check for a provider in all children injectors\n     * @param {string|Symbol} name\n     * @return {boolean}\n     */\n    hasChildProvider(name) {\n        return Boolean(this.$children.find(i => i.has(name)));\n    }\n\n    /**\n     * Register a provider for a value meant to be a singleton instance\n     * @param {string|Symbol} name\n     * @param {Function|Class} value\n     */\n    provideShared(name, value) {\n        return this.provide(name, value, true);\n    }\n\n    /**\n     * Register a provider for a value meant to be recreated everytime it is required\n     * @param {string|Symbol} name\n     * @param {Function|Class} value\n     */\n    provideNotShared(name, value) {\n        return this.provide(name, value, false);\n    }\n\n    /**\n     * Register a provider for a value\n     * @param {string|Symbol} name\n     * @param {Function|Class} value\n     * @param {boolean} isShared\n     */\n    provide(name, value, isShared = true) {\n        if (is.object(name)) {\n            Object.keys(name).forEach(k => this.provide(k, name[k], isShared));\n            return;\n        }\n\n        if (this.$frozen) {\n            throw new Error(INJECTOR_FROZEN_ERROR);\n        }\n\n        if (is.array(value)) {\n            let provider = value[value.length - 1];\n\n            if (!is.function(provider)) {\n                throw new Error('Invalid provider for ' + name);\n            }\n\n            this._register(name, value, isShared);\n            return this;\n        }\n\n        if (is.function(value)) {\n            let provider = this._parseDependencies(value);\n            provider.push(value);\n\n            this._register(name, provider, isShared);\n            return this;\n        }\n\n        this.constant(name, value);\n        return this;\n    }\n\n    /**\n     * Provider to any value that won't change during the injector lifecycle\n     * @param {string|Symbol} name\n     * @param {*} value\n     */\n    constant(name, value) {\n        if (is.object(name)) {\n            Object.keys(name).forEach(k => this.constant(k, name[k]));\n            return;\n        }\n\n        if (this.$frozen) {\n            throw new Error(INJECTOR_FROZEN_ERROR);\n        }\n\n        this.$cache.set(name, value);\n        return this;\n    }\n\n    /**\n     * @param {string} name\n     * @param {Object} [locals]\n     */\n    instantiate(name, locals) {\n        function Constructor() {}\n\n        let instance, returnedValue;\n        const Type = this.$providers.get(name);\n\n        if (!Type) return;\n\n        Constructor.prototype = (is.array(Type) ? Type[Type.length - 1] : Type).prototype;\n\n        instance = new Constructor();\n        returnedValue = this.invoke(Type, instance, locals);\n        instance = (is.object(returnedValue) || is.function(returnedValue)) ? returnedValue : instance;\n\n        return instance;\n    }\n\n    /**\n     * @param {Function|Array} invokable    Either a function or an array with dependencies and a function\n     * @param {Object} context\n     * @param {Object} [locals]\n     *\n     * @example\n     *\n     * function fn(foo) {}\n     * const context = {};\n     *\n     * handbag.invoke(fn, context, { foo: 1 });\n     * handbag.invoke(['foo', fn], context, { foo: 1 });\n     */\n    invoke(invokable, context, locals) {\n        let _invokable;\n\n        if (is.array(invokable)) {\n            _invokable = this._getInvokableFromArray(invokable);\n        } else if (is.function(invokable)) {\n            _invokable = this._getInvokableFromFunction(invokable);\n        }\n\n        if (!(_invokable && _invokable.method)) {\n            throw new Error('Invalid invokable value');\n        }\n\n        let { dependencies } = _invokable;\n\n        if (dependencies.length) {\n            dependencies = this.get(dependencies, locals);\n        }\n\n        return _invokable.method.apply(context || null, dependencies);\n    }\n\n    _getInvokableFromArray(array) {\n        let dependencies = array.slice(0);\n        let method = dependencies.pop();\n\n        if (!is.function(method)) {\n            method = null;\n        }\n\n        return { dependencies, method };\n    }\n\n    _getInvokableFromFunction(fn) {\n        let dependencies = fn.$inject || this._parseDependencies(fn);\n\n        return { dependencies, method: fn };\n    }\n\n    _annotateConstructor() {\n        var args = Array.from(arguments),\n            Constructor = args.pop();\n\n        Constructor.$inject = args;\n\n        return Constructor;\n    }\n\n    _parseDependencies(fn) {\n        var match = fn.toString().match(FN_ARGS),\n            fnArgs = match && match[1];\n\n        return fnArgs && fnArgs.split(',').map(function(arg) {\n            return arg.trim();\n        }) || [];\n    }\n\n    _register(name, provider, isShared) {\n        if (this.$providers.has(name)) {\n            throw new Error('Cannot register a dependency that already exists: ' + name);\n        }\n\n        const value = this._annotateConstructor.apply(null, provider);\n        this.$providers.set(name, value);\n\n        if (!isShared) {\n            this.$privates[name] = true;\n        }\n    }\n\n    /**\n     * Lock this injector to prevent any further registration of values\n     */\n    freeze() {\n        this.$frozen = true;\n    }\n\n    /**\n     * Reset all the values declared in this injector\n     * @private\n     */\n    _reset() {\n        this.$cache = new Map();\n        this.$providers = new Map();\n        this.$privates = {};\n        this.$stack = [];\n        this.$children = [];\n    }\n\n    /**\n     * @param {Injector} injector\n     */\n    addInjector(injector) {\n        this.$children.push(injector);\n    }\n\n    /**\n     * @return {Injector}\n     */\n    static createInjector() {\n        return new Injector();\n    }\n}\n\nexport default Injector;\n"],"names":["toString","Object","prototype","INSTANTIATING","INJECTOR_FROZEN_ERROR","is","value","call","FN_ARGS","UID","Injector","_reset","id","name","locals","Error","array","map","item","this","get","isInLocals","hasOwnProperty","getOwnPropertySymbols","indexOf","stack","$stack","has","error","length","join","getResource","hasLocalProvider","getLocalResource","injector","$children","find","i","cache","$cache","_isInstantiating","push","set","instantiate","undefined","e","pop","$privates","hasChildProvider","$providers","Boolean","provide","isShared","object","keys","forEach","_this","k","$frozen","provider","_register","_provider","_parseDependencies","constant","_this2","Constructor","instance","returnedValue","Type","invoke","invokable","context","_invokable","_getInvokableFromArray","_getInvokableFromFunction","method","dependencies","apply","slice","fn","$inject","args","Array","from","arguments","match","fnArgs","split","arg","trim","_annotateConstructor","Map"],"mappings":"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"}